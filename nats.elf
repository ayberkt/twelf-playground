nat  : type.
z    : nat.
s    : nat -> nat.

even   : nat -> type.
even-z : even z.
even-s : even N -> even (s (s N)).

plus   : nat -> nat -> nat -> type.
plus-z : plus z N N.
plus-s :  plus N1 N2 N3 -> plus (s N1) N2 (s N3).

%mode plus +N1 +N2 -N3.
%worlds () (plus _ _ _).
%total N1 (plus N1 _ _).

sum-evens : even N1 -> even N2 -> plus N1 N2 N3 -> even N3 -> type.
%mode sum-evens +D1 +D2 +D3 -D4.

sez : sum-evens even-z (D : even N2) (plus-z : plus z N2 N2) D.

ses : sum-evens
       ((even-s D) : even (s (s N1')))
       (E : even N2)
       ((plus-s (plus-s Dplus)) : plus (s (s N1')) N2 (s (s N3')))
       (even-s F)
    <- sum-evens D E Dplus F.

%worlds () (sum-evens _ _ _ _).
%total D (sum-evens D _ _ _).

% We need the following lemma for `plus-comm`.
plus-id-right : {N:nat} (plus N z N) -> type.
%mode plus-id-right +N -D.
plus-id-right-z : plus-id-right z plus-z.
plus-id-right-s : plus-id-right (s N) (plus-s D) <- plus-id-right N D.
%worlds () (plus-id-right _ _).
%total N (plus-id-right N _).

% TODO
plus-comm : plus N1 N2 N3 -> plus N2 N1 N3 -> type.

odd   : nat -> type.
odd-z : odd (s z).
odd-s : odd N -> odd (s (s N)).

% Lemma 1 for `plus-comm`.
succ-even-odd : even N -> odd (s N) -> type.
succ-even-z   : succ-even-odd even-z odd-z.
succ-even-s   : succ-even-odd
                  ((even-s D) : even (s (s N)))
                  ((odd-s F) : odd (s (s (s N))))
              <- succ-even-odd D F.

% Lemma 2 for `plus-comm`.
plus-flip : plus N1 N2 N3 -> plus N1 (s N2) (s N3) -> type.
%mode plus-flip +D1 -D2.

plus-flip-z : plus-flip (plus-z : (plus z N2 N2)) plus-z.

plus-flip-s : plus-flip
                ((plus-s D)  : (plus (s N1') N2 (s N3')))
                ((plus-s IH) : (plus (s N1') (s N2) (s (s N3'))))
            <- plus-flip D IH.

succ-odd : odd N -> even (s N) -> type.
%mode succ-odd +D1 -D2.

succ-odd-z : succ-odd (odd-z : odd (s z)) (even-s even-z).
succ-odd-s : succ-odd D F -> succ-odd (odd-s D) (even-s F).
%worlds () (succ-odd _ _).
%total D (succ-odd D _).
